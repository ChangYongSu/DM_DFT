/* -LICENSE-START-
** Copyright (c) 2013 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
** 
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/


#include "stdafx.h"
#include <gl/gl.h>
#include "PreviewWindow.h"

PreviewWindow::PreviewWindow()
 : m_refCount(1), m_deckLinkScreenPreviewHelper(NULL), m_previewBox(NULL), m_previewBoxDC(NULL), m_openGLctx(NULL)
{}

PreviewWindow::~PreviewWindow()
{
	if (m_deckLinkScreenPreviewHelper != NULL)
	{
		m_deckLinkScreenPreviewHelper->Release();
		m_deckLinkScreenPreviewHelper = NULL;
	}

	if (m_openGLctx != NULL)
	{
		wglDeleteContext(m_openGLctx);
		m_openGLctx = NULL;
	}

	if (m_previewBoxDC != NULL)
	{
		m_previewBox->ReleaseDC(m_previewBoxDC);
		m_previewBoxDC = NULL;
	}
}

bool		PreviewWindow::init(CStatic *previewBox)
{
	m_previewBox = previewBox;

	// Create the DeckLink screen preview helper
	if (CoCreateInstance(CLSID_CDeckLinkGLScreenPreviewHelper, NULL, CLSCTX_ALL, IID_IDeckLinkGLScreenPreviewHelper, (void**)&m_deckLinkScreenPreviewHelper) != S_OK)
		return false;

	// Initialise OpenGL
	return initOpenGL();
}

bool		PreviewWindow::initOpenGL()
{
	PIXELFORMATDESCRIPTOR	pixelFormatDesc;
	int						pixelFormat;
	bool					result = false;

	//
	// Here, we create an OpenGL context attached to the screen preview box
	// so we can use it later on when we need to draw preview frames.

	// Get the preview box drawing context
	m_previewBoxDC = m_previewBox->GetDC();//m_hDC
	if (m_previewBoxDC == NULL)
		return false;

	// Ensure the preview box DC uses ARGB pixel format
	ZeroMemory(&pixelFormatDesc, sizeof(pixelFormatDesc));
	pixelFormatDesc.nSize = sizeof(pixelFormatDesc);
	pixelFormatDesc.nVersion = 1;
	pixelFormatDesc.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL;
	pixelFormatDesc.iPixelType = PFD_TYPE_RGBA;
	pixelFormatDesc.cColorBits = 32;
	pixelFormatDesc.cDepthBits = 16;
	pixelFormatDesc.cAlphaBits = 8;
	pixelFormatDesc.iLayerType = PFD_MAIN_PLANE;
	pixelFormat = ChoosePixelFormat(m_previewBoxDC->m_hDC, &pixelFormatDesc);
	if (SetPixelFormat(m_previewBoxDC->m_hDC, pixelFormat, &pixelFormatDesc) == false)
		return false;

	// Create OpenGL rendering context
	m_openGLctx = wglCreateContext(m_previewBoxDC->m_hDC);
	if (m_openGLctx == NULL)
		return false;

	// Make the new OpenGL context the current rendering context so
	// we can initialise the DeckLink preview helper
	if (wglMakeCurrent(m_previewBoxDC->m_hDC, m_openGLctx) == FALSE)
		return false;

	if (m_deckLinkScreenPreviewHelper->InitializeGL() == S_OK)
		result = true;

	// Reset the OpenGL rendering context
	wglMakeCurrent(NULL, NULL);

	m_DisplayFlag = 0;
	m_DisplayOK = 0;


	return result;
}

HRESULT 	PreviewWindow::QueryInterface(REFIID iid, LPVOID *ppv)
{
	*ppv = NULL;
	return E_NOINTERFACE;
}
ULONG		PreviewWindow::AddRef()
{
	return InterlockedIncrement((LONG*)&m_refCount);
}
ULONG		PreviewWindow::Release()
{
	ULONG		newRefValue;

	newRefValue = InterlockedDecrement((LONG*)&m_refCount);
	if (newRefValue == 0)
	{
		delete this;
		return 0;
	}

	return newRefValue;
}


ULONG		PreviewWindow::GetImageData(void **buffer)
{
	ULONG		newRefValue;

	//m_deckLinkScreenPreviewHelper->
/*
	newRefValue = InterlockedDecrement((LONG*)&m_refCount);
	if (newRefValue == 0)
	{
		delete this;
		return 0;
	}
*/
	return newRefValue;
}



HRESULT			PreviewWindow::DrawFrame(IDeckLinkVideoFrame* theFrame)
{
	// Make sure we are initialised
	if ((m_deckLinkScreenPreviewHelper == NULL) || (m_previewBoxDC == NULL) || (m_openGLctx == NULL))
		return E_FAIL;

	// First, pass the frame to the DeckLink screen preview helper
	m_deckLinkScreenPreviewHelper->SetFrame(theFrame);

	m_pref_theFrame = theFrame;

//	theFrame->GetAncillaryData();
	//theFrame->GetBytes()

	//long lHight = theFrame->GetHeight();
	//long lWidth = theFrame->GetWidth();
	//long lRowByte = theFrame->GetRowBytes();

	//BYTE pImageData[1920 *4];
	////ImageData = pImageData;//BYTE **
	//BYTE *ImageData;
	//ImageData = new BYTE[1920*1280*3];
	//theFrame->GetBytes((void **)ImageData);
	////memcpy(pImageData, ImageData,sizeof( pImageData));
	//int j = 0;
	//for (int i = 0; i < 1920  ; i++)
	//{
	//	for (j = 0; j < 4; j++)
	//	{
	//		pImageData[i*4+ j] = ImageData[j];
	//	}
	//	theFrame->GetBytes((void **)ImageData);
	//}
	//delete ImageData;

	// Then set the OpenGL rendering context to the one we created before
	wglMakeCurrent(m_previewBoxDC->m_hDC, m_openGLctx);
	//glPushMatrix();
	//glBegin(GL_QUADS);
	//	glColor3f(1.0f,0.0f,0.0f);
	//	glVertex3f(-1.0f,-1.0,0.0f);
	//	glColor3f(0.0f,1.0f,0.0f);
	//	glVertex3f(1.0f,-1.0f,0.0f);
	//	glColor3f(0.0f,0.0f,1.0f);
	//	glVertex3f(1.0f,1.0f,0.0f);
	//	glColor3f(0.0f,1.0f,1.0f);
	//	glVertex3f(-1.0f,0.7f,0.0f);
	//glEnd();
	//glPopMatrix();

	// and let the helper take care of the drawing
	m_deckLinkScreenPreviewHelper->PaintGL();


	DisplayRange(m_Rect);

	// Last, reset the OpenGL rendering context
	wglMakeCurrent(NULL, NULL);

	return S_OK;
}


		
bool PreviewWindow::SetRange(int lOn, CRect lRect)
{
	if(lOn)
	{
		m_Rect = lRect;
		m_DisplayFlag = 1;
	}
	else
	{
		m_Rect.left = 0;
		m_Rect.right = 0;
		m_Rect.top = 0;
		m_Rect.bottom = 0;
		m_DisplayFlag = 0;
		m_DisplayOK = 0;
	}
	return 1;
}
	
void PreviewWindow::DisplayRange(CRect lRect)
{
	//540, 440
		//CRect rectPASS_Type;
		//rectPASS_Type.left =250;
		//rectPASS_Type.top = 70;
		//rectPASS_Type.right =360;
		//rectPASS_Type.bottom = 95;
		//lRect = rectPASS_Type;


	if(m_DisplayFlag == 1)
	{
		if((lRect.left > 0)&&(lRect.top > 0)&&(lRect.right > lRect.left)&&(lRect.bottom > lRect.top))
		{
			float x1,x2,y1, y2;
			//x1 = lRect.left/540.0*2 - 1;
			//x2 = lRect.right/540.0*2 - 1;
			//y1 = (440.0-lRect.top)/440.0*2 - 1;
			//y2 = (440.0-lRect.bottom)/440.0*2 - 1;
			x1 = lRect.left/316.0 - 1.01;
			x2 = lRect.right/316.0 - 0.99;
			y1 = (322.0-lRect.top)/161.0 -  0.99;
			y2 = (322.0-lRect.bottom)/161.0 - 1.01;

			glPushMatrix();
			glLineWidth(3);
			if(m_DisplayOK)
				glColor3f(0.0f,1.0f,0.0f);//
			else
				glColor3f(1.0f,0.0f,0.0f);//

				glBegin(GL_LINE_STRIP);

				glVertex3f(x1, y1, 0.0f);	
				glVertex3f(x2, y1, 0.0f);	
				glVertex3f(x2, y2, 0.0f);	
				glVertex3f(x1, y2, 0.0f);
				glVertex3f(x1, y1, 0.0f);	
	
								
		
				glEnd();	
			glPopMatrix();


			//x1 = lRect.left/270.0 - 1.0;
			//x2 = lRect.right/270.0 - 1.0;
			//y1 = (440.0-lRect.top)/220.0 -  1.0;
			//y2 = (440.0-lRect.bottom)/220.0 - 1.0;

			//glPushMatrix();
			//glLineWidth(1);
			//glColor3f(0.0f,1.0f,0.0f);//
			//	glBegin(GL_LINE_STRIP);

			//	glVertex3f(x1, y1, 0.0f);	
			//	glVertex3f(x2, y1, 0.0f);	
			//	glVertex3f(x2, y2, 0.0f);	
			//	glVertex3f(x1, y2, 0.0f);
			//	glVertex3f(x1, y1, 0.0f);	
	
			//					
		
			//	glEnd();	
			//glPopMatrix();

		}
			
	}
}
	
